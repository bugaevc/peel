from peel_dbus_gen.utils import camel_case_to_underscore

class Method:
    def __init__(self, attrs, iface):
        self.iface = iface
        self.dbus_name = attrs.get('name')
        self.cpp_name = camel_case_to_underscore(self.dbus_name)
        self.arguments = []

    def generate_arg_lists(self):
        self.in_args = ''.join(arg.generate_cpp_type() + ', ' for arg in self.arguments if arg.direction == 'in')
        self.in_args_forward = ''.join('std::move ({}), '.format(arg.name) for arg in self.arguments if arg.direction == 'in')
        self.out_args = ''.join(arg.generate_cpp_type() + ', ' for arg in self.arguments if arg.direction == 'out')
        self.out_args_forward = ''.join('{}, '.format(arg.name) for arg in self.arguments if arg.direction == 'out')

    def generate_header(self):
        self.generate_arg_lists()
        return '\n'.join([
            '  template<typename AsyncReadyCallback>',
            '  void',
            '  {}_async ({}'.format(self.cpp_name, self.in_args.strip()),
            '    AsyncReadyCallback &&callback, ::peel::Gio::Cancellable *cancellable = nullptr,',
            '    ::peel::Gio::DBusCallFlags bus_call_flags = ::peel::Gio::DBusCallFlags::NONE, int bus_call_timeout_msec = -1) noexcept',
            '  {',
            '    gpointer _peel_user_data;',
            '    ::GAsyncReadyCallback _peel_callback = ::peel::internals::CallbackHelper<void, ::GObject *, ::GAsyncResult *>::wrap_async_callback (',
            '      static_cast<AsyncReadyCallback &&> (callback),',
            '      [] (::GObject *source_object, ::GAsyncResult *res, gpointer data) -> void',
            '      {',
            '        AsyncReadyCallback &callback = reinterpret_cast<AsyncReadyCallback &> (*reinterpret_cast<unsigned char *> (data));',
            '        ::peel::GObject::Object *_peel_source_object = reinterpret_cast<::peel::GObject::Object *> (source_object);',
            '        ::peel::Gio::AsyncResult *_peel_res = reinterpret_cast<::peel::Gio::AsyncResult *> (res);',
            '        static_cast<AsyncReadyCallback &&> (callback) (_peel_source_object, _peel_res);',
            '      },',
            '      &_peel_user_data);',
            '    {}::Iface *_peel_iface = get_interface<{}> ();'.format(self.iface.emit_name, self.iface.emit_name),
            '    _peel_iface->_peel_vfunc_{}_async (this, {}_peel_callback, _peel_user_data, cancellable, bus_call_flags, bus_call_timeout_msec);'.format(self.cpp_name, self.in_args_forward),
            '  }',
            '',
            '  bool',
            '  {}_finish ({}::peel::Gio::AsyncResult *async_result, ::peel::UniquePtr<::peel::GLib::Error> *error) noexcept'.format(self.cpp_name, self.out_args),
            '  {',
            '    {}::Iface *_peel_iface = get_interface<{}> ();'.format(self.iface.emit_name, self.iface.emit_name),
            '    return _peel_iface->_peel_vfunc_{}_finish (this, {}async_result, error);'.format(self.cpp_name, self.out_args_forward),
            '  }',
            '',
            '  bool',
            '  {}_sync ({}'.format(self.cpp_name, (self.in_args + self.out_args).strip()),
            '    ::peel::UniquePtr<::peel::GLib::Error> *error, ::peel::Gio::Cancellable *cancellable = nullptr,',
            '    ::peel::Gio::DBusCallFlags bus_call_flags = ::peel::Gio::DBusCallFlags::NONE, int bus_call_timeout_msec = -1) noexcept',
            '  {',
            '    {}::Iface *_peel_iface = get_interface<{}> ();'.format(self.iface.emit_name, self.iface.emit_name),
            '    return _peel_iface->_peel_vfunc_{}_sync (this, {}{}error, cancellable, bus_call_flags, bus_call_timeout_msec);'.format(self.cpp_name, self.in_args_forward, self.out_args_forward),
            '  }',
        ])

    def generate_vfunc_ptr(self):
        self.generate_arg_lists()
        return '\n'.join([
            '    void (*_peel_vfunc_{}_async) ({} *self, {}'.format(self.cpp_name, self.iface.emit_name, self.in_args.strip()),
            '      ::GAsyncReadyCallback, gpointer user_data, ::peel::Gio::Cancellable *, ::peel::Gio::DBusCallFlags, int bus_call_timeout_msec);',
            '    bool (*_peel_vfunc_{}_finish) ({} *self, {}'.format(self.cpp_name, self.iface.emit_name, self.out_args.strip()),
            '      ::peel::Gio::AsyncResult *, ::peel::UniquePtr<::peel::GLib::Error> *);',
            '    bool (*_peel_vfunc_{}_sync) ({} *self, {}'.format(self.cpp_name, self.iface.emit_name, (self.in_args + self.out_args).strip()),
            '      ::peel::UniquePtr<::peel::GLib::Error> *, ::peel::Gio::Cancellable *, ::peel::Gio::DBusCallFlags, int bus_call_timeout_msec);',
        ])

    def generate_override_vfunc_method(self):
        self.generate_arg_lists()
        return '\n'.join([
            '    template<typename DerivedClass>',
            '    void',
            '    override_vfunc_{}_async ()'.format(self.cpp_name),
            '    {',
            '      _peel_vfunc_{}_async = +[] ({} *self, {}'.format(self.cpp_name, self.iface.emit_name, self.in_args.strip()),
            '        ::GAsyncReadyCallback callback, gpointer user_data, ::peel::Gio::Cancellable *cancellable, ::peel::Gio::DBusCallFlags bus_call_flags, int bus_call_timeout_msec) -> void',
            '        {',
            '          DerivedClass *_peel_this = reinterpret_cast<DerivedClass *> (self);',
            '          _peel_this->DerivedClass::vfunc_{}_async ({}callback, user_data, cancellable, bus_call_flags, bus_call_timeout_msec);'.format(self.cpp_name, self.in_args_forward),
            '        };',
            '    }',
            '',
            '    template<typename DerivedClass>',
            '    void',
            '    override_vfunc_{}_finish ()'.format(self.cpp_name),
            '    {',
            '      _peel_vfunc_{}_finish = +[] ({} *self, {}'.format(self.cpp_name, self.iface.emit_name, self.out_args.strip()),
            '        ::peel::Gio::AsyncResult *async_result, ::peel::UniquePtr<::peel::GLib::Error> *error) -> bool',
            '        {',
            '          DerivedClass *_peel_this = reinterpret_cast<DerivedClass *> (self);',
            '          return _peel_this->DerivedClass::vfunc_{}_finish ({}async_result, error);'.format(self.cpp_name, self.out_args_forward),
            '        };',
            '    }',
            '',
            '    template<typename DerivedClass>',
            '    void',
            '    override_vfunc_{}_sync ()'.format(self.cpp_name),
            '    {',
            '      _peel_vfunc_{}_sync = +[] ({} *self, {}'.format(self.cpp_name, self.iface.emit_name, (self.in_args + self.out_args).strip()),
            '        ::peel::UniquePtr<::peel::GLib::Error> *error, ::peel::Gio::Cancellable *cancellable, ::peel::Gio::DBusCallFlags bus_call_flags, int bus_call_timeout_msec) -> bool',
            '        {',
            '          DerivedClass *_peel_this = reinterpret_cast<DerivedClass *> (self);',
            '          return _peel_this->DerivedClass::vfunc_{}_sync ({}{}error, cancellable, bus_call_flags, bus_call_timeout_msec);'.format(self.cpp_name, self.in_args_forward, self.out_args_forward),
            '        };',
            '    }',
        ])

    def generate_iface_init(self, iface_expr):
        return '\n'.join([
            '  {}->_peel_vfunc_{}_async = {}_default_{}_async;'.format(iface_expr, self.cpp_name, self.iface.emit_name, self.cpp_name),
            '  {}->_peel_vfunc_{}_finish = {}_default_{}_finish;'.format(iface_expr, self.cpp_name, self.iface.emit_name, self.cpp_name),
            '  {}->_peel_vfunc_{}_sync = {}_default_{}_sync;'.format(iface_expr, self.cpp_name, self.iface.emit_name, self.cpp_name),
        ])

    def generate_proxy_iface_init(self, iface_expr):
        return '\n'.join([
            '  {}->_peel_vfunc_{}_async = {}_proxy_{}_async;'.format(iface_expr, self.cpp_name, self.iface.emit_name, self.cpp_name),
            '  {}->_peel_vfunc_{}_finish = {}_proxy_{}_finish;'.format(iface_expr, self.cpp_name, self.iface.emit_name, self.cpp_name),
            '  {}->_peel_vfunc_{}_sync = {}_proxy_{}_sync;'.format(iface_expr, self.cpp_name, self.iface.emit_name, self.cpp_name),
        ])

    def generate_default_vfuncs(self):
        self.generate_arg_lists()
        return '\n'.join([
            'static void',
            '{}_default_{}_async ({} *self, {}'.format(self.iface.emit_name, self.cpp_name, self.iface.emit_name, self.in_args.strip()),
            '  ::GAsyncReadyCallback, gpointer user_data, ::peel::Gio::Cancellable *, ::peel::Gio::DBusCallFlags, int bus_call_timeout_msec);',
            'static bool',
            '{}_default_{}_finish ({} *self, {}'.format(self.iface.emit_name, self.cpp_name, self.iface.emit_name, self.out_args.strip()),
            '  ::peel::Gio::AsyncResult *, ::peel::UniquePtr<::peel::GLib::Error> *);',
            'static bool',
            '{}_default_{}_sync ({} *self, {}'.format(self.iface.emit_name, self.cpp_name, self.iface.emit_name, (self.in_args + self.out_args).strip()),
            '  ::peel::UniquePtr<::peel::GLib::Error> *, ::peel::Gio::Cancellable *, ::peel::Gio::DBusCallFlags, int bus_call_timeout_msec);',
            '',
            'struct {}{}Data'.format(self.iface.emit_name, self.dbus_name),
            '{',
            '  /* TODO: in args */',
            '  /* TODO: out args */',
            '  ::peel::Gio::DBusCallFlags bus_call_flags;',
            '  int bus_call_timeout_msec;',
            '};',
            '',
            'static void',
            '{}_{}_data_free (gpointer d)'.format(self.iface.emit_name, self.cpp_name),
            '{',
            '  {}{}Data *data = reinterpret_cast<{}{}Data *> (d);'.format(self.iface.emit_name, self.dbus_name, self.iface.emit_name, self.dbus_name),
            '  /* TODO: release args */',
            '  g_slice_free ({}{}Data, d);'.format(self.iface.emit_name, self.dbus_name),
            '}',
            '',
            'static void',
            '{}_default_{}_async ({} *self, {}'.format(self.iface.emit_name, self.cpp_name, self.iface.emit_name, self.in_args.strip()),
            '  ::GAsyncReadyCallback callback, gpointer user_data, ::peel::Gio::Cancellable *cancellable, ::peel::Gio::DBusCallFlags bus_call_flags, int bus_call_timeout_msec)',
            '{',
            '  {}::Iface *iface = self->get_interface<{}> ();'.format(self.iface.emit_name, self.iface.emit_name),
            '  if (G_UNLIKELY (iface->_peel_vfunc_{}_sync == {}_default_{}_sync))'.format(self.cpp_name, self.iface.emit_name, self.cpp_name),
            '    {',
            '      g_critical ("{} of type \'%s\' does not implement {}::{}", self->get_type_name ());'.format(self.iface.emit_name, self.iface.emit_name, self.cpp_name),
            '      return;',
            '    }',
            '',
            '  {}{}Data *task_data = g_slice_new ({}{}Data);'.format(self.iface.emit_name, self.dbus_name, self.iface.emit_name, self.dbus_name),
            '  task_data->bus_call_flags = bus_call_flags;',
            '  task_data->bus_call_timeout_msec = bus_call_timeout_msec;',
            '  ::GTask *task = g_task_new (self, reinterpret_cast<::GCancellable *> (cancellable), callback, user_data);',
            '  g_task_set_task_data (task, task_data, {}_{}_data_free);'.format(self.iface.emit_name, self.cpp_name),
            '  g_task_run_in_thread (task, +[] (::GTask *task, gpointer source_object, gpointer d, ::GCancellable *cancellable)',
            '    {',
            '      {} *self = reinterpret_cast<{} *> (source_object);'.format(self.iface.emit_name, self.iface.emit_name),
            '      {}{}Data *task_data = reinterpret_cast<{}{}Data *> (d);'.format(self.iface.emit_name, self.dbus_name, self.iface.emit_name, self.dbus_name),
            '      ::peel::UniquePtr<::peel::GLib::Error> error;',
            '      ::peel::Gio::Cancellable *_peel_cancellable = reinterpret_cast<::peel::Gio::Cancellable *> (cancellable);',
            '      {}::Iface *iface = self->get_interface<{}> ();'.format(self.iface.emit_name, self.iface.emit_name),
            '      // iface->_peel_vfunc_{}_sync (self, /* TODO: in args, out args, */ &error, _peel_cancellable, task_data->bus_call_flags, task_data->bus_call_timeout_msec);'.format(self.cpp_name),
            '      if (error)',
            '        g_task_return_error (task, reinterpret_cast<::GError *> (std::move (error).release_ref ()));',
            '      else',
            '        g_task_return_boolean (task, TRUE);',
            '    });',
            '  g_object_unref (task);',
            '}',
            '',
            'static bool',
            '{}_default_{}_finish ({} *self, {}'.format(self.iface.emit_name, self.cpp_name, self.iface.emit_name, self.out_args.strip()),
            '  ::peel::Gio::AsyncResult *async_result, ::peel::UniquePtr<::peel::GLib::Error> *error)',
            '{',
            '  g_return_val_if_fail (::peel::Gio::Task::is_valid (async_result, self), false);',
            '  ::peel::Gio::Task *task = async_result->cast<::peel::Gio::Task> ();',
            '  // TODO: copy out args',
            '  return task->propagate_boolean (error);',
            '}',
            '',
            'static bool',
            '{}_default_{}_sync ({} *self, {}'.format(self.iface.emit_name, self.cpp_name, self.iface.emit_name, (self.in_args + self.out_args).strip()),
            '  ::peel::UniquePtr<::peel::GLib::Error> *error, ::peel::Gio::Cancellable *cancellable, ::peel::Gio::DBusCallFlags bus_call_flags, int bus_call_timeout_msec)',
            '{',
            '  {}::Iface *iface = self->get_interface<{}> ();'.format(self.iface.emit_name, self.iface.emit_name),
            '  if (G_UNLIKELY (iface->_peel_vfunc_{}_async == {}_default_{}_async))'.format(self.cpp_name, self.iface.emit_name, self.cpp_name),
            '    {',
            '      g_critical ("{} of type \'%s\' does not implement {}::{}", self->get_type_name ());'.format(self.iface.emit_name, self.iface.emit_name, self.cpp_name),
            '      return false;',
            '    }',
            '',
            '  bool completed = false;',
            '  bool result;',
            '  ::peel::RefPtr<::peel::GLib::MainContext> main_context = ::peel::GLib::MainContext::create ();',
            '  main_context->push_thread_default ();',
            '  self->{}_async ({}[{}error, &completed, &result] (::peel::GObject::Object *source_object, ::peel::Gio::AsyncResult *res)'.format(self.cpp_name, self.in_args_forward, self.out_args_forward),
            '    {',
            '      result = source_object->cast<{}> ()->{}_finish ({}res, error);'.format(self.iface.emit_name, self.cpp_name, self.out_args_forward),
            '      completed = true;',
            '    }, cancellable, bus_call_flags, bus_call_timeout_msec);',
            '  while (!completed)',
            '    main_context->iteration (true);',
            '  main_context->pop_thread_default ();',
            '  return result;',
            '}',
        ])

    def generate_proxy_vfuncs(self):
        self.generate_arg_lists()
        num_in_args = len([arg for arg in self.arguments if arg.direction == 'in'])
        in_args = ',\n'.join('      ' + arg.generate_make_variant() for arg in self.arguments if arg.direction == 'in')
        return '\n'.join([
            'static void',
            '{}_proxy_{}_async ({} *self, {}'.format(self.iface.emit_name, self.cpp_name, self.iface.emit_name, self.in_args.strip()),
            '  ::GAsyncReadyCallback callback, gpointer user_data, ::peel::Gio::Cancellable *cancellable, ::peel::Gio::DBusCallFlags bus_call_flags, int bus_call_timeout_msec)',
            '{',
            '  ::GDBusProxy *proxy = G_DBUS_PROXY (self);',
            '  ::GVariant *_peel_args[{}]'.format(num_in_args),
            '    {',
            in_args,
            '    };',
            '  g_dbus_proxy_call (proxy, "{}", g_variant_new_tuple (_peel_args, {}),'.format(self.dbus_name, num_in_args),
            '    static_cast<::GDBusCallFlags> (bus_call_flags), bus_call_timeout_msec, reinterpret_cast<::GCancellable *> (cancellable), callback, user_data);',
            '}',
            '',
            'static bool',
            '{}_proxy_{}_finish ({} *self, {}'.format(self.iface.emit_name, self.cpp_name, self.iface.emit_name, self.out_args.strip()),
            '  ::peel::Gio::AsyncResult *async_result, ::peel::UniquePtr<::peel::GLib::Error> *error)',
            '{',
            '  ::peel::Gio::DBusProxy *proxy = self->cast<::peel::Gio::DBusProxy> ();',
            '  ::peel::RefPtr<::peel::GLib::Variant> out_v = proxy->call_finish (async_result, error);',
            '  if (!out_v)',
            '    return false;',
            '  return true;',
            '}',
            '',
            'static bool',
            '{}_proxy_{}_sync ({} *self, {}'.format(self.iface.emit_name, self.cpp_name, self.iface.emit_name, (self.in_args + self.out_args).strip()),
            '  ::peel::UniquePtr<::peel::GLib::Error> *error, ::peel::Gio::Cancellable *cancellable, ::peel::Gio::DBusCallFlags bus_call_flags, int bus_call_timeout_msec)',
            '{',
            '  ::GDBusProxy *proxy = G_DBUS_PROXY (self);',
            '  ::GVariant *_peel_args[{}]'.format(num_in_args),
            '    {',
            in_args,
            '    };',
            '  ::GError *_peel_error = nullptr;',
            '  ::GVariant *out_v = g_dbus_proxy_call_sync (proxy, "{}", g_variant_new_tuple (_peel_args, {}),'.format(self.dbus_name, num_in_args),
            '    static_cast<::GDBusCallFlags> (bus_call_flags), bus_call_timeout_msec, reinterpret_cast<::GCancellable *> (cancellable), &_peel_error);',
            '  if (!out_v)',
            '    {'
            '      if (error)',
            '        *error = ::peel::UniquePtr<::peel::GLib::Error>::adopt_ref (reinterpret_cast<::peel::GLib::Error *> (_peel_error));',
            '      return false;',
            '    }',
            '  if (error)',
            '    *error = nullptr;',
            '  // TODO: out args',
            '  return true;',
            '}',
        ])
